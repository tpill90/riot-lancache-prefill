namespace RiotPrefill.Debug
{
    public static class NginxLogParser
    {
        /// <summary>
        /// Gets the most recently saved request logs for the specified product.  The request logs will be generated by installing a product (ex. Starcraft)
        /// using the Battle.Net client, and then saving off the logged requests from Nginx.  These request files can then be compared against, to verify if
        /// our application is making the same requests as Battle.Net, without actually having to make the requests (saves bandwidth and time)
        /// </summary>
        /// <param name="logBasePath">Root folder where all log files are stored.</param>
        /// <param name="product">Target product to be parsed.  Used to determine subfolder to search for files</param>
        /// <returns>A list of all requests made by the real Battle.Net client.</returns>
        //public static List<Request> GetSavedRequestLogs(string logBasePath, TactProduct product)
        //{
        //    var timer = Stopwatch.StartNew();
        //    var logFolder = $"{logBasePath}/{product.DisplayNameSanitized}";

        //    var latestFile = new DirectoryInfo(logFolder)
        //                            .GetFiles()
        //                            .OrderByDescending(e => e.LastWriteTime)
        //                            .FirstOrDefault();

        //    // Loading the pre-computed log file if it exists, speeds up subsequent runs
        //    if (latestFile.FullName.Contains("coalesced"))
        //    {
        //        return JsonSerializer.Deserialize(File.ReadAllText(latestFile.FullName), SerializationContext.Default.ListRequest);
        //    }
        //    if (latestFile.Extension == ".zip")
        //    {
        //        // Extract the logs, so that we can read them while debugging
        //        ZipFile.ExtractToDirectory(latestFile.FullName, latestFile.Directory.FullName, true);
        //        var logFilePath = latestFile.FullName.Replace(".zip", ".log");

        //        var rawLogs = ParseRequestLogs(File.ReadAllLines(logFilePath));
        //        List<Request> requestsToReplay = RequestUtils.CoalesceRequests(rawLogs);

        //        // Save the coalesced results to speed up future runs
        //        var coalescedFileName = $"{logFolder}/{latestFile.Name.Replace(".zip", ".coalesced.log")}";
        //        File.WriteAllText(coalescedFileName, JsonSerializer.Serialize(requestsToReplay, SerializationContext.Default.ListRequest));

        //        AnsiConsole.Console.LogMarkupLine("Parsed request logs", timer);
        //        return requestsToReplay;
        //    }

        //    throw new FileNotFoundException($"Unable to find replay logs for {product.DisplayName}");
        //}

        //TODO should write unit tests for some of this
        public static List<Request> ParseRequestLogs(string[] rawRequests)
        {
            var timer = Stopwatch.StartNew();
            var parsedRequests = new List<Request>();

            rawRequests = rawRequests.Where(e => e != null).ToArray();

            var counter = 0;
            //TODO the way that I'm doing this is a disaster, refactor it once working
            foreach (var rawRequest in rawRequests)
            {
                // Only interested in GET requests from Riot.  Filtering out any other requests from other clients like Steam
                if (!(rawRequest.Contains("GET") && rawRequest.Contains("[riot]")))
                {
                    continue;
                }
                // Filter out lancache heartbeat
                if (rawRequest.Contains("heartbeat"))
                {
                    continue;
                }

                // Gets the requested URL from the request log.
                // URL example : /channels/public/bundles/75C5FDE7CB917359.bundle.
                var requestUrlMatch = Regex.Match(rawRequest, @"\""GET\s(\/[^\s]+)\sHTTP\/1\.1\""");
                var requestUrl = requestUrlMatch.Groups[1].Value;
                var bundleKey = requestUrl.Replace("/channels/public/bundles/", "").Replace(".bundle", "");


                var byteMatch = Regex.Match(rawRequest, @"bytes=(\d+-\d+)(,(\d+-\d+))*").Value;
                var ranges = byteMatch.Replace("bytes=", "").Split(",");
                foreach (var range in ranges)
                {
                    var bytesSplit = range.Split("-");
                    var parsedRequest = new Request()
                    {
                        BundleKey = bundleKey,
                        LowerByteRange = long.Parse(bytesSplit[0]),
                        UpperByteRange = long.Parse(bytesSplit[1])
                    };

                    parsedRequests.Add(parsedRequest);
                }
            }

            AnsiConsole.Console.LogMarkupLine($"Parsed {LightYellow(parsedRequests.Count)} log entries", timer);
            return parsedRequests;
        }

        //public static string GetLatestLogVersionForProduct(string logBasePath, TactProduct product)
        //{
        //    var logFolder = $@"{logBasePath}\{product.DisplayNameSanitized}";

        //    if (!Directory.Exists(logFolder))
        //    {
        //        Directory.CreateDirectory(logFolder);
        //    }

        //    var latestFile = new DirectoryInfo(logFolder)
        //        .GetFiles()
        //        .Where(e => e.Extension == ".zip")
        //        .OrderByDescending(e => e.LastWriteTime)
        //        .FirstOrDefault();

        //    if (latestFile == null)
        //    {
        //        return "";
        //    }

        //    return latestFile.Name.Replace(".zip", "");
        //}
    }
}